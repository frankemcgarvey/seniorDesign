/*
 * dsp.c
 *
 *  Created on: Jul 3, 2021
 *      Author: Chris
 */

#include "dsp.h"


static float coeff[TAPS] = {0.0000000000, 0.0000073007, 0.0000124341, 0.0000138200, 0.0000100336, -0.0000000000, -0.0000168279, -0.0000403307, -0.0000696413, -0.0001031370, -0.0001385128, -0.0001729364, -0.0002032766, -0.0002263896, -0.0002394373, -0.0002402103, -0.0002274203, -0.0002009315, -0.0001618987, -0.0001127898, -0.0000572780, -0.0000000000, 0.0000538098, 0.0000987869, 0.0001299723, 0.0001433707, 0.0001364817, 0.0001087504, 0.0000618851, -0.0000000000, -0.0000704530, -0.0001409774, -0.0002015508, -0.0002413475, -0.0002496241, -0.0002167071, -0.0001350108, -0.0000000000, 0.0001889891, 0.0004281532, 0.0007089242, 0.0010180244, 0.0013379042, 0.0016475673, 0.0019237524, 0.0021424131, 0.0022804075, 0.0023172853, 0.0022370421, 0.0020297045, 0.0016926105, 0.0012312621, 0.0006596524, -0.0000000000, -0.0007181334, -0.0014593248, -0.0021843029, -0.0028523817, -0.0034241635, -0.0038643287, -0.0041443125, -0.0042446612, -0.0041568725, -0.0038845486, -0.0034437327, -0.0028623497, -0.0021787346, -0.0014393005, -0.0006954628, 0.0000000000, 0.0005969126, 0.0010517238, 0.0013312859, 0.0014160935, 0.0013027064, 0.0010051180, 0.0005548962, -0.0000000000, -0.0005977377, -0.0011663697, -0.0016286547, -0.0019076661, -0.0019328420, -0.0016460780, -0.0010074304, 0.0000000000, 0.0013664060, 0.0030531806, 0.0049926496, 0.0070897836, 0.0092259155, 0.0112643595, 0.0130576914, 0.0144563265, 0.0153179249, 0.0155170706, 0.0149546216, 0.0135661155, 0.0113286410, 0.0082656513, 0.0044492985, -0.0000000000, -0.0049168912, -0.0100972697, -0.0153070921, -0.0202934316, -0.0247972253, -0.0285670450, -0.0313731302, -0.0330208800, -0.0333630008, -0.0323095609, -0.0298352982, -0.0259836715, -0.0208673183, -0.0146647845, -0.0076136012, 0.0000000000, 0.0078542440, 0.0156071756, 0.0229134253, 0.0294414798, 0.0348905161, 0.0390058706, 0.0415922823, 0.0425241645, 0.0415922823, 0.0390058706, 0.0348905161, 0.0294414798, 0.0229134253, 0.0156071756, 0.0078542440, 0.0000000000, -0.0076136012, -0.0146647845, -0.0208673183, -0.0259836715, -0.0298352982, -0.0323095609, -0.0333630008, -0.0330208800, -0.0313731302, -0.0285670450, -0.0247972253, -0.0202934316, -0.0153070921, -0.0100972697, -0.0049168912, -0.0000000000, 0.0044492985, 0.0082656513, 0.0113286410, 0.0135661155, 0.0149546216, 0.0155170706, 0.0153179249, 0.0144563265, 0.0130576914, 0.0112643595, 0.0092259155, 0.0070897836, 0.0049926496, 0.0030531806, 0.0013664060, 0.0000000000, -0.0010074304, -0.0016460780, -0.0019328420, -0.0019076661, -0.0016286547, -0.0011663697, -0.0005977377, -0.0000000000, 0.0005548962, 0.0010051180, 0.0013027064, 0.0014160935, 0.0013312859, 0.0010517238, 0.0005969126, 0.0000000000, -0.0006954628, -0.0014393005, -0.0021787346, -0.0028623497, -0.0034437327, -0.0038845486, -0.0041568725, -0.0042446612, -0.0041443125, -0.0038643287, -0.0034241635, -0.0028523817, -0.0021843029, -0.0014593248, -0.0007181334, -0.0000000000, 0.0006596524, 0.0012312621, 0.0016926105, 0.0020297045, 0.0022370421, 0.0023172853, 0.0022804075, 0.0021424131, 0.0019237524, 0.0016475673, 0.0013379042, 0.0010180244, 0.0007089242, 0.0004281532, 0.0001889891, -0.0000000000, -0.0001350108, -0.0002167071, -0.0002496241, -0.0002413475, -0.0002015508, -0.0001409774, -0.0000704530, -0.0000000000, 0.0000618851, 0.0001087504, 0.0001364817, 0.0001433707, 0.0001299723, 0.0000987869, 0.0000538098, -0.0000000000, -0.0000572780, -0.0001127898, -0.0001618987, -0.0002009315, -0.0002274203, -0.0002402103, -0.0002394373, -0.0002263896, -0.0002032766, -0.0001729364, -0.0001385128, -0.0001031370, -0.0000696413, -0.0000403307, -0.0000168279, -0.0000000000, 0.0000100336, 0.0000138200, 0.0000124341, 0.0000073007, 0.0000000000};

void matrix_init(uint32_t numRow, uint32_t numCol, uint16_t* matrix, arm_matrix_instance_q15* instance, uint32_t offset){

	for(uint32_t i = 0; i < 2; i++){
		arm_mat_init_q15(&instance[i], numRow, numCol, (q15_t*)&matrix[offset*i]);
	}
}

void FIR_Filter_F32_Init(dsp_buffer_t* buff, uint32_t channelNumber){
	for(uint32_t i = 0; i < channelNumber; i++){
		arm_fir_init_f32(buff[i].lpFilter_inst, TAPS, &coeff[0], &buff[i].state[0], BLOCK_SIZE);
	}
}

void FIR_Filter_F32(dsp_buffer_t* dsp, float (*input)[BLOCK_SIZE], float (*output)[BLOCK_SIZE] , uint32_t channelNumber){
	for(uint32_t i = 0; i < channelNumber; i++){
		arm_fir_f32(dsp[i].lpFilter_inst, &input[i][0], &output[i][0], BLOCK_SIZE);
	}
}



void FFT_Init(arm_rfft_fast_instance_f32* fft_instance, uint32_t channelNumber){
	for(uint32_t i = 0; i < channelNumber; i++){
		arm_rfft_fast_init_f32(&fft_instance[i], FFT_LEN);
	}
}

void Q15_To_Float(q15_t (*q15)[Q15_FLOAT_LEN], float (*flt)[Q15_FLOAT_LEN], uint32_t channelNumber){
	for(uint32_t i = 0; i < channelNumber; i++){
		arm_q15_to_float(&q15[i][0], &flt[i][0], Q15_FLOAT_LEN);
	}
}

void Float_To_Q15(float (*flt)[Q15_FLOAT_LEN], q15_t (*q15)[Q15_FLOAT_LEN], uint32_t channelNumber){
	for(uint32_t i = 0; i < channelNumber; i++){
		arm_float_to_q15(&flt[i][0], &q15[i][0], Q15_FLOAT_LEN);
	}
}
#define FALSE 				0
#define fft_conjugate_j 	fft_output_j
#define fft_absolute_i_j	fft_output_i

void GCC_PHAT(arm_rfft_fast_instance_f32* fft_instance_i, float *fft_input_i, arm_rfft_fast_instance_f32* fft_instance_j, float *fft_input_j, float* Gphat_output){

	static float fft_output_i[FFT_LEN+2];
	static float fft_output_j[FFT_LEN+2];
	static float fft_multi_i_j[FFT_LEN+2];

	//FFT Signals I & J
	arm_rfft_fast_f32(&fft_instance_i[0], &fft_input_i[0], &fft_output_i[0], FALSE);
	arm_rfft_fast_f32(&fft_instance_j[0], &fft_input_j[0], &fft_output_j[0], FALSE);

	//Take the conjugate of signal J
	arm_cmplx_conj_f32(&fft_output_j[2], &fft_conjugate_j[2], FFT_LEN/2 - 1);

	//Re-assign the values for J
	fft_conjugate_j[FFT_LEN-2] 	= fft_output_j[1];
	fft_conjugate_j[FFT_LEN-1] 	= 0;
	fft_conjugate_j[1] 			= 0;

	//Re-assign the value for I
	fft_output_i[FFT_LEN-2] 	= fft_output_i[1];
	fft_output_i[FFT_LEN-1] 	= 0;
	fft_output_i[1] 			= 0;

	//Multiply the Top
	arm_cmplx_mult_cmplx_f32(&fft_output_i[0], &fft_conjugate_j[0], &fft_multi_i_j[0], (FFT_LEN+2)/2);

	//Find the bottoms magnitude
	arm_cmplx_mag_f32(&fft_multi_i_j[0], &fft_absolute_i_j[0], (FFT_LEN+2)/2);

	//Take the inverse of each one
	for(uint32_t i = 0; i < (FFT_LEN+2)/2; i++){
		fft_absolute_i_j[i] = 1/fft_absolute_i_j[i];
	}

	//Multiply the top with the bottom
	arm_cmplx_mult_real_f32(&fft_multi_i_j[0], &fft_absolute_i_j[0], &Gphat_output[0], (FFT_LEN+2)/2);
}
